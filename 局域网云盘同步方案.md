# å±€åŸŸç½‘äº‘ç›˜åŒæ­¥æ‰©å±•æ–¹æ¡ˆ

## æ¦‚è¿°

åŸºäºç°æœ‰çš„ Airdrop æ¶æ„ï¼ˆDiscovery + Session + Transferï¼‰ï¼Œæ‰©å±•ä¸ºæ”¯æŒå±€åŸŸç½‘å†…å¤šè®¾å¤‡æ–‡ä»¶è‡ªåŠ¨åŒæ­¥çš„äº‘ç›˜ç³»ç»Ÿã€‚

---

## æ ¸å¿ƒç‰¹æ€§

1. **è‡ªåŠ¨ç›‘æ§**: ç›‘æ§æŒ‡å®šç›®å½•çš„æ–‡ä»¶å˜åŒ–ï¼ˆæ–°å¢ã€ä¿®æ”¹ã€åˆ é™¤ï¼‰
2. **å®æ—¶åŒæ­¥**: æ–‡ä»¶å˜åŒ–åè‡ªåŠ¨åŒæ­¥åˆ°å…¶ä»–è®¾å¤‡
3. **åŒå‘åŒæ­¥**: æ”¯æŒå¤šè®¾å¤‡é—´ç›¸äº’åŒæ­¥
4. **å¢é‡ä¼ è¾“**: åªä¼ è¾“å˜åŒ–çš„éƒ¨åˆ†ï¼Œæé«˜æ•ˆç‡
5. **å†²çªè§£å†³**: è‡ªåŠ¨æˆ–æ‰‹åŠ¨è§£å†³æ–‡ä»¶å†²çª
6. **é€‰æ‹©æ€§åŒæ­¥**: å¯é…ç½®å¿½ç•¥ç‰¹å®šæ–‡ä»¶/ç›®å½•

---

## æ¶æ„è®¾è®¡

### æ¨¡å—åˆ’åˆ†

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Daemon Core                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚Discovery â”‚  â”‚ Session â”‚  â”‚   Transfer     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚       â”‚             â”‚             â”‚             â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                     â”‚                           â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚       â”‚                           â”‚             â”‚
â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ Watcher â”‚  â”‚  Sync  â”‚  â”‚  Metadata  â”‚      â”‚
â”‚  â”‚  æ¨¡å—   â”‚â”€â–ºâ”‚  æ¨¡å—  â”‚â—„â”€â”‚    æ¨¡å—    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                    â”‚                           â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚              â”‚  Conflict  â”‚                    â”‚
â”‚              â”‚   è§£å†³å™¨    â”‚                    â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ•°æ®æµ

```
æ–‡ä»¶å˜åŒ– â†’ Watcher â†’ SyncEvent â†’ Syncæ¨¡å—
                                    â†“
                            åˆ¤æ–­æ˜¯å¦éœ€è¦åŒæ­¥
                                    â†“
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚                           â”‚
                    æœ¬åœ°                        è¿œç¨‹
                      â†“                           â†“
                æ›´æ–° Metadata              Transfer å‘é€æ–‡ä»¶
                      â†“                           â†“
                  æŒä¹…åŒ–åˆ°DB                 æ¥æ”¶ç«¯å¤„ç†
```

---

## æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 1. Watcher æ¨¡å—ï¼ˆæ–‡ä»¶ç›‘æ§ï¼‰

**ä¾èµ–**: `notify` crate

**åŠŸèƒ½**:
- ç›‘æ§æŒ‡å®šç›®å½•çš„æ–‡ä»¶ç³»ç»Ÿäº‹ä»¶
- è¿‡æ»¤ä¸´æ—¶æ–‡ä»¶å’Œå¿½ç•¥è§„åˆ™
- é˜²æŠ–å¤„ç†ï¼ˆé¿å…çŸ­æ—¶é—´å†…é‡å¤äº‹ä»¶ï¼‰

**ä»£ç ç»“æ„** ([crates/sync/src/watcher.rs](crates/sync/src/watcher.rs)):

```rust
use notify::{Config, Event, RecommendedWatcher, RecursiveMode, Watcher as NotifyWatcher};
use std::path::{Path, PathBuf};
use tokio::sync::mpsc;
use std::time::Duration;

pub struct FileWatcher {
    watcher: RecommendedWatcher,
    watch_dir: PathBuf,
    ignore_patterns: Vec<String>,
}

#[derive(Debug, Clone)]
pub enum FileEvent {
    Created(PathBuf),
    Modified(PathBuf),
    Deleted(PathBuf),
    Renamed { from: PathBuf, to: PathBuf },
}

impl FileWatcher {
    pub fn new(
        watch_dir: PathBuf,
        event_tx: mpsc::Sender<FileEvent>,
        ignore_patterns: Vec<String>,
    ) -> anyhow::Result<Self> {
        let (notify_tx, mut notify_rx) = mpsc::channel(100);

        // åˆ›å»º notify watcher
        let mut watcher = RecommendedWatcher::new(
            move |res: Result<Event, _>| {
                if let Ok(event) = res {
                    notify_tx.blocking_send(event).ok();
                }
            },
            Config::default().with_poll_interval(Duration::from_secs(1)),
        )?;

        watcher.watch(&watch_dir, RecursiveMode::Recursive)?;

        // åå°ä»»åŠ¡ï¼šå¤„ç†äº‹ä»¶å¹¶å»é‡
        let ignore_patterns_clone = ignore_patterns.clone();
        let watch_dir_clone = watch_dir.clone();
        tokio::spawn(async move {
            let mut debounce_map = std::collections::HashMap::new();
            let debounce_duration = Duration::from_millis(500);

            while let Some(event) = notify_rx.recv().await {
                // è¿‡æ»¤é€»è¾‘
                if Self::should_ignore(&event, &watch_dir_clone, &ignore_patterns_clone) {
                    continue;
                }

                // é˜²æŠ–å¤„ç†
                let file_event = Self::convert_event(event);
                if let Some(fe) = file_event {
                    // ç®€å•é˜²æŠ–ï¼šå»¶è¿Ÿå‘é€
                    event_tx.send(fe).await.ok();
                }
            }
        });

        Ok(Self {
            watcher,
            watch_dir,
            ignore_patterns,
        })
    }

    fn should_ignore(event: &Event, watch_dir: &Path, patterns: &[String]) -> bool {
        // æ£€æŸ¥æ˜¯å¦åŒ¹é…å¿½ç•¥è§„åˆ™ï¼ˆ.gitignoreé£æ ¼ï¼‰
        for path in &event.paths {
            let relative = path.strip_prefix(watch_dir).unwrap_or(path);
            for pattern in patterns {
                if glob_match::glob_match(pattern, &relative.to_string_lossy()) {
                    return true;
                }
            }
        }
        false
    }

    fn convert_event(event: Event) -> Option<FileEvent> {
        use notify::EventKind;
        match event.kind {
            EventKind::Create(_) => Some(FileEvent::Created(event.paths[0].clone())),
            EventKind::Modify(_) => Some(FileEvent::Modified(event.paths[0].clone())),
            EventKind::Remove(_) => Some(FileEvent::Deleted(event.paths[0].clone())),
            EventKind::Rename(_) if event.paths.len() == 2 => {
                Some(FileEvent::Renamed {
                    from: event.paths[0].clone(),
                    to: event.paths[1].clone(),
                })
            }
            _ => None,
        }
    }
}
```

---

### 2. Metadata æ¨¡å—ï¼ˆå…ƒæ•°æ®ç®¡ç†ï¼‰

**ä¾èµ–**: `sled` (åµŒå…¥å¼æ•°æ®åº“) æˆ– `rusqlite`

**åŠŸèƒ½**:
- å­˜å‚¨æ–‡ä»¶å…ƒæ•°æ®ï¼ˆè·¯å¾„ã€å¤§å°ã€ä¿®æ”¹æ—¶é—´ã€å“ˆå¸Œï¼‰
- è¿½è¸ªæ–‡ä»¶ç‰ˆæœ¬
- å†²çªæ£€æµ‹

**æ•°æ®ç»“æ„**:

```rust
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileMetadata {
    pub relative_path: PathBuf,       // ç›¸å¯¹äºåŒæ­¥æ ¹ç›®å½•çš„è·¯å¾„
    pub size: u64,
    pub modified_time: u64,           // Unix timestamp
    pub hash: String,                 // BLAKE3 hash
    pub version: u64,                 // ç‰ˆæœ¬å·
    pub device_id: String,            // æœ€åä¿®æ”¹çš„è®¾å¤‡ID
    pub deleted: bool,                // æ˜¯å¦å·²åˆ é™¤
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncState {
    pub local_version: u64,
    pub remote_versions: HashMap<String, u64>, // device_id -> version
}
```

**ä»£ç ** ([crates/sync/src/metadata.rs](crates/sync/src/metadata.rs)):

```rust
use sled::Db;
use std::path::{Path, PathBuf};

pub struct MetadataStore {
    db: Db,
    sync_root: PathBuf,
}

impl MetadataStore {
    pub fn new(db_path: &Path, sync_root: PathBuf) -> anyhow::Result<Self> {
        let db = sled::open(db_path)?;
        Ok(Self { db, sync_root })
    }

    /// è·å–æ–‡ä»¶å…ƒæ•°æ®
    pub fn get(&self, relative_path: &Path) -> anyhow::Result<Option<FileMetadata>> {
        if let Some(bytes) = self.db.get(relative_path.to_string_lossy().as_bytes())? {
            let metadata: FileMetadata = bincode::deserialize(&bytes)?;
            Ok(Some(metadata))
        } else {
            Ok(None)
        }
    }

    /// ä¿å­˜æ–‡ä»¶å…ƒæ•°æ®
    pub fn set(&self, metadata: &FileMetadata) -> anyhow::Result<()> {
        let key = metadata.relative_path.to_string_lossy();
        let value = bincode::serialize(metadata)?;
        self.db.insert(key.as_bytes(), value)?;
        Ok(())
    }

    /// åˆ é™¤å…ƒæ•°æ®
    pub fn delete(&self, relative_path: &Path) -> anyhow::Result<()> {
        self.db.remove(relative_path.to_string_lossy().as_bytes())?;
        Ok(())
    }

    /// åˆ—å‡ºæ‰€æœ‰å…ƒæ•°æ®
    pub fn list_all(&self) -> anyhow::Result<Vec<FileMetadata>> {
        let mut result = Vec::new();
        for item in self.db.iter() {
            let (_, value) = item?;
            let metadata: FileMetadata = bincode::deserialize(&value)?;
            result.push(metadata);
        }
        Ok(result)
    }

    /// è®¡ç®—æ–‡ä»¶å“ˆå¸Œ
    pub async fn compute_hash(file_path: &Path) -> anyhow::Result<String> {
        use blake3::Hasher;
        use tokio::io::AsyncReadExt;

        let mut file = tokio::fs::File::open(file_path).await?;
        let mut hasher = Hasher::new();
        let mut buffer = vec![0; 8192];

        loop {
            let n = file.read(&mut buffer).await?;
            if n == 0 {
                break;
            }
            hasher.update(&buffer[..n]);
        }

        Ok(hasher.finalize().to_hex().to_string())
    }
}
```

---

### 3. Sync æ¨¡å—ï¼ˆåŒæ­¥é€»è¾‘ï¼‰

**åŠŸèƒ½**:
- å¤„ç†æœ¬åœ°æ–‡ä»¶å˜åŒ–
- å†³ç­–åŒæ­¥ç­–ç•¥ï¼ˆä¸Šä¼ /ä¸‹è½½/å†²çªï¼‰
- ç®¡ç†åŒæ­¥é˜Ÿåˆ—

**ä»£ç ** ([crates/sync/src/manager.rs](crates/sync/src/manager.rs)):

```rust
use std::path::{Path, PathBuf};
use tokio::sync::mpsc;
use crate::{
    watcher::{FileEvent, FileWatcher},
    metadata::{FileMetadata, MetadataStore},
};

pub struct SyncManager {
    sync_root: PathBuf,
    device_id: String,
    metadata_store: MetadataStore,
    watcher: FileWatcher,

    // é€šä¿¡é€šé“
    sync_event_tx: mpsc::Sender<SyncEvent>,
    file_event_rx: mpsc::Receiver<FileEvent>,
}

#[derive(Debug)]
pub enum SyncEvent {
    UploadFile {
        relative_path: PathBuf,
        metadata: FileMetadata,
    },
    DeleteFile {
        relative_path: PathBuf,
    },
    RequestFile {
        relative_path: PathBuf,
        from_device: String,
    },
    Conflict {
        relative_path: PathBuf,
        local: FileMetadata,
        remote: FileMetadata,
    },
}

impl SyncManager {
    pub fn new(
        sync_root: PathBuf,
        device_id: String,
        db_path: &Path,
    ) -> anyhow::Result<Self> {
        let (file_event_tx, file_event_rx) = mpsc::channel(100);
        let (sync_event_tx, sync_event_rx) = mpsc::channel(100);

        let metadata_store = MetadataStore::new(db_path, sync_root.clone())?;

        // å¿½ç•¥è§„åˆ™
        let ignore_patterns = vec![
            ".git/**".to_string(),
            "node_modules/**".to_string(),
            ".DS_Store".to_string(),
            "*.tmp".to_string(),
        ];

        let watcher = FileWatcher::new(
            sync_root.clone(),
            file_event_tx,
            ignore_patterns,
        )?;

        Ok(Self {
            sync_root,
            device_id,
            metadata_store,
            watcher,
            sync_event_tx,
            file_event_rx,
        })
    }

    /// å¯åŠ¨åŒæ­¥å¾ªç¯
    pub async fn run(&mut self) {
        while let Some(file_event) = self.file_event_rx.recv().await {
            if let Err(e) = self.handle_file_event(file_event).await {
                tracing::error!("Failed to handle file event: {:?}", e);
            }
        }
    }

    async fn handle_file_event(&self, event: FileEvent) -> anyhow::Result<()> {
        match event {
            FileEvent::Created(path) | FileEvent::Modified(path) => {
                self.handle_file_change(path).await?;
            }
            FileEvent::Deleted(path) => {
                self.handle_file_deletion(path).await?;
            }
            FileEvent::Renamed { from, to } => {
                self.handle_file_deletion(from).await?;
                self.handle_file_change(to).await?;
            }
        }
        Ok(())
    }

    async fn handle_file_change(&self, full_path: PathBuf) -> anyhow::Result<()> {
        let relative_path = full_path.strip_prefix(&self.sync_root)?.to_path_buf();

        // è®¡ç®—å…ƒæ•°æ®
        let metadata = tokio::fs::metadata(&full_path).await?;
        let hash = MetadataStore::compute_hash(&full_path).await?;

        // æ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ–
        let old_metadata = self.metadata_store.get(&relative_path)?;
        let needs_sync = match old_metadata {
            Some(old) => old.hash != hash,
            None => true,
        };

        if needs_sync {
            let new_version = old_metadata.map(|m| m.version + 1).unwrap_or(1);
            let file_metadata = FileMetadata {
                relative_path: relative_path.clone(),
                size: metadata.len(),
                modified_time: metadata.modified()?.duration_since(std::time::UNIX_EPOCH)?.as_secs(),
                hash,
                version: new_version,
                device_id: self.device_id.clone(),
                deleted: false,
            };

            // ä¿å­˜åˆ°æœ¬åœ°æ•°æ®åº“
            self.metadata_store.set(&file_metadata)?;

            // å‘é€åŒæ­¥äº‹ä»¶
            self.sync_event_tx.send(SyncEvent::UploadFile {
                relative_path,
                metadata: file_metadata,
            }).await?;
        }

        Ok(())
    }

    async fn handle_file_deletion(&self, full_path: PathBuf) -> anyhow::Result<()> {
        let relative_path = full_path.strip_prefix(&self.sync_root)?.to_path_buf();

        // æ ‡è®°ä¸ºå·²åˆ é™¤
        if let Some(mut metadata) = self.metadata_store.get(&relative_path)? {
            metadata.deleted = true;
            metadata.version += 1;
            self.metadata_store.set(&metadata)?;

            self.sync_event_tx.send(SyncEvent::DeleteFile {
                relative_path,
            }).await?;
        }

        Ok(())
    }

    /// æ¥æ”¶è¿œç¨‹æ–‡ä»¶å˜åŒ–
    pub async fn on_remote_change(&self, remote_metadata: FileMetadata) -> anyhow::Result<()> {
        let local_metadata = self.metadata_store.get(&remote_metadata.relative_path)?;

        match local_metadata {
            None => {
                // æœ¬åœ°ä¸å­˜åœ¨ï¼Œç›´æ¥è¯·æ±‚ä¸‹è½½
                self.sync_event_tx.send(SyncEvent::RequestFile {
                    relative_path: remote_metadata.relative_path.clone(),
                    from_device: remote_metadata.device_id.clone(),
                }).await?;
            }
            Some(local) => {
                // æ£€æµ‹å†²çª
                if local.version < remote_metadata.version {
                    if local.hash != remote_metadata.hash {
                        // æœ‰å†²çª
                        self.sync_event_tx.send(SyncEvent::Conflict {
                            relative_path: remote_metadata.relative_path.clone(),
                            local,
                            remote: remote_metadata,
                        }).await?;
                    } else {
                        // å†…å®¹ç›¸åŒï¼Œåªæ›´æ–°ç‰ˆæœ¬å·
                        let mut updated = local;
                        updated.version = remote_metadata.version;
                        self.metadata_store.set(&updated)?;
                    }
                }
                // æœ¬åœ°ç‰ˆæœ¬æ›´æ–°ï¼Œå¿½ç•¥
            }
        }

        Ok(())
    }
}
```

---

### 4. Conflict æ¨¡å—ï¼ˆå†²çªè§£å†³ï¼‰

**ç­–ç•¥**:
1. **Last Write Wins**: æœ€åä¿®æ”¹çš„ç‰ˆæœ¬èƒœå‡º
2. **Manual**: ä¿ç•™ä¸¤ä¸ªç‰ˆæœ¬ï¼Œè®©ç”¨æˆ·é€‰æ‹©
3. **Copy Both**: é‡å‘½åå†²çªæ–‡ä»¶ï¼ˆfile_conflict_devicename.extï¼‰

```rust
pub enum ConflictStrategy {
    LastWriteWins,
    Manual,
    CopyBoth,
}

pub struct ConflictResolver {
    strategy: ConflictStrategy,
}

impl ConflictResolver {
    pub fn resolve(
        &self,
        local: &FileMetadata,
        remote: &FileMetadata,
    ) -> ConflictResolution {
        match self.strategy {
            ConflictStrategy::LastWriteWins => {
                if local.modified_time > remote.modified_time {
                    ConflictResolution::KeepLocal
                } else {
                    ConflictResolution::KeepRemote
                }
            }
            ConflictStrategy::CopyBoth => {
                ConflictResolution::SaveBoth
            }
            ConflictStrategy::Manual => {
                ConflictResolution::AskUser { local: local.clone(), remote: remote.clone() }
            }
        }
    }
}

pub enum ConflictResolution {
    KeepLocal,
    KeepRemote,
    SaveBoth,
    AskUser { local: FileMetadata, remote: FileMetadata },
}
```

---

## ä¸ç°æœ‰æ¶æ„é›†æˆ

### Transfer æ¨¡å—æ‰©å±•

æ·»åŠ åŒæ­¥åè®®å‘½ä»¤ï¼š

```rust
// crates/transfer/src/protocol.rs
#[derive(Serialize, Deserialize)]
pub enum SyncMessage {
    // æ–‡ä»¶å…ƒæ•°æ®å¹¿æ’­
    MetadataUpdate(FileMetadata),

    // è¯·æ±‚æ–‡ä»¶
    RequestFile { relative_path: PathBuf },

    // æ–‡ä»¶ä¼ è¾“ï¼ˆå¤ç”¨ç°æœ‰çš„ FileHeader + dataï¼‰
    FileData { header: FileHeader, /* stream */ },

    // åˆ é™¤é€šçŸ¥
    DeleteNotification { relative_path: PathBuf },
}
```

### Daemon é›†æˆ

```rust
// crates/daemon/src/main.rs
async fn main() {
    // ... ç°æœ‰åˆå§‹åŒ– ...

    // åŒæ­¥ç®¡ç†å™¨
    let sync_root = PathBuf::from("./sync");
    let mut sync_manager = SyncManager::new(
        sync_root,
        device_name.clone(),
        Path::new("./sync.db"),
    )?;

    tokio::spawn(async move {
        sync_manager.run().await;
    });

    // ä¸»å¾ªç¯æ·»åŠ  sync äº‹ä»¶å¤„ç†
    loop {
        tokio::select! {
            // ... ç°æœ‰åˆ†æ”¯ ...

            Some(sync_event) = sync_rx.recv() => {
                match sync_event {
                    SyncEvent::UploadFile { relative_path, metadata } => {
                        // å¹¿æ’­åˆ°æ‰€æœ‰åœ¨çº¿è®¾å¤‡
                        broadcast_metadata_update(metadata).await;
                    }
                    SyncEvent::RequestFile { relative_path, from_device } => {
                        // å‘é€æ–‡ä»¶åˆ°æŒ‡å®šè®¾å¤‡
                    }
                    _ => {}
                }
            }
        }
    }
}
```

---

## é…ç½®æ–‡ä»¶

**sync_config.toml**:
```toml
[sync]
# åŒæ­¥æ ¹ç›®å½•
root = "./sync"

# è®¾å¤‡åç§°ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰
device_id = "device-uuid"

# å†²çªè§£å†³ç­–ç•¥
conflict_strategy = "last_write_wins" # last_write_wins | copy_both | manual

# å¿½ç•¥è§„åˆ™ï¼ˆ.gitignore æ ¼å¼ï¼‰
ignore = [
    ".git/**",
    "node_modules/**",
    "*.tmp",
    ".DS_Store"
]

# æ˜¯å¦å¯ç”¨å¢é‡åŒæ­¥ï¼ˆrsync-styleï¼‰
incremental = true

# æ˜¯å¦å‹ç¼©ä¼ è¾“
compress = true
```

---

## å®æ–½æ­¥éª¤

### Phase 1: åŸºç¡€ç›‘æ§ï¼ˆ1-2å‘¨ï¼‰
1. âœ… åˆ›å»º `sync` crate
2. âœ… å®ç° Watcher æ¨¡å—
3. âœ… å®ç° Metadata æ¨¡å—
4. âœ… åŸºæœ¬çš„äº‹ä»¶å¤„ç†å¾ªç¯

### Phase 2: åŒæ­¥é€»è¾‘ï¼ˆ2-3å‘¨ï¼‰
5. âœ… å®ç° SyncManager
6. âœ… é›†æˆåˆ° Transfer æ¨¡å—
7. âœ… å®ç°æ–‡ä»¶ä¸Šä¼ /ä¸‹è½½é€»è¾‘
8. âœ… æµ‹è¯•å•å‘åŒæ­¥

### Phase 3: å†²çªå¤„ç†ï¼ˆ1-2å‘¨ï¼‰
9. âœ… å®ç° ConflictResolver
10. âœ… æµ‹è¯•å†²çªåœºæ™¯
11. âœ… UI æ˜¾ç¤ºå†²çªï¼ˆå¦‚æœä½¿ç”¨ Tauriï¼‰

### Phase 4: ä¼˜åŒ–ï¼ˆ1-2å‘¨ï¼‰
12. âœ… å¢é‡ä¼ è¾“ï¼ˆrsyncç®—æ³• æˆ– diff-basedï¼‰
13. âœ… å‹ç¼©ä¼ è¾“
14. âœ… æ€§èƒ½ä¼˜åŒ–å’Œæµ‹è¯•

---

## æŠ€æœ¯æ ˆ

- **æ–‡ä»¶ç›‘æ§**: `notify` v6
- **æ•°æ®åº“**: `sled` (åµŒå…¥å¼) æˆ– `rusqlite`
- **å“ˆå¸Œ**: `blake3` (å¿«é€Ÿä¸”å®‰å…¨)
- **å¿½ç•¥è§„åˆ™**: `globset` æˆ– `ignore` (ripgrepçš„åº“)
- **å¢é‡åŒæ­¥**: `rsync-core` æˆ–è‡ªå®ç° rolling hash

---

## å…³é”®æŒ‘æˆ˜ä¸è§£å†³æ–¹æ¡ˆ

### 1. å¤§æ–‡ä»¶åŒæ­¥
**é—®é¢˜**: ä¼ è¾“å¤§æ–‡ä»¶è€—æ—¶ä¸”å®¹æ˜“ä¸­æ–­
**æ–¹æ¡ˆ**:
- ä½¿ç”¨ QUIC çš„æµæ§åˆ¶
- åˆ†å—ä¼ è¾“ + æ–­ç‚¹ç»­ä¼ 
- å¯é€‰ï¼šCDC (Content-Defined Chunking) å¢é‡åŒæ­¥

### 2. å¹¶å‘ä¿®æ”¹
**é—®é¢˜**: å¤šè®¾å¤‡åŒæ—¶ä¿®æ”¹åŒä¸€æ–‡ä»¶
**æ–¹æ¡ˆ**:
- åŸºäºæ—¶é—´æˆ³çš„å†²çªæ£€æµ‹
- CRDT (Conflict-free Replicated Data Types) ç”¨äºæ–‡æœ¬æ–‡ä»¶ï¼ˆå¯é€‰ï¼‰
- æä¾›æ˜ç¡®çš„å†²çªè§£å†³ç•Œé¢

### 3. åˆ é™¤ä¼ æ’­
**é—®é¢˜**: å¦‚ä½•ç¡®ä¿åˆ é™¤æ“ä½œåŒæ­¥åˆ°æ‰€æœ‰è®¾å¤‡
**æ–¹æ¡ˆ**:
- è½¯åˆ é™¤ï¼ˆæ ‡è®° deleted=trueï¼‰
- ä¿ç•™å…ƒæ•°æ®ä¸€æ®µæ—¶é—´
- å®šæœŸåƒåœ¾å›æ”¶

### 4. åˆå§‹åŒæ­¥
**é—®é¢˜**: æ–°è®¾å¤‡åŠ å…¥æ—¶éœ€è¦åŒæ­¥å¤§é‡æ–‡ä»¶
**æ–¹æ¡ˆ**:
- å¢é‡æ‰«æ + ä¼˜å…ˆçº§é˜Ÿåˆ—
- å¯é€‰ï¼šæ”¯æŒ"éƒ¨åˆ†åŒæ­¥"ï¼ˆåªåŒæ­¥æŒ‡å®šå­ç›®å½•ï¼‰
- æ˜¾ç¤ºåŒæ­¥è¿›åº¦

---

## UI è®¾è®¡ï¼ˆTaurié›†æˆï¼‰

### åŒæ­¥çŠ¶æ€é¢æ¿
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“ åŒæ­¥æ–‡ä»¶å¤¹: ~/Documents/Sync    â”‚
â”‚  âœ… åŒæ­¥çŠ¶æ€: å·²åŒæ­¥                 â”‚
â”‚  ğŸ“Š å·²åŒæ­¥: 1234 æ–‡ä»¶ (5.6 GB)      â”‚
â”‚                                     â”‚
â”‚  åœ¨çº¿è®¾å¤‡:                          â”‚
â”‚  â€¢ MacBook Pro (æœ¬æœº)               â”‚
â”‚  â€¢ Windows PC (192.168.1.10) âœ…     â”‚
â”‚  â€¢ iPad (192.168.1.20) â¸ï¸ æš‚åœ      â”‚
â”‚                                     â”‚
â”‚  æœ€è¿‘åŒæ­¥:                          â”‚
â”‚  â€¢ report.pdf (2åˆ†é’Ÿå‰) â†‘           â”‚
â”‚  â€¢ image.jpg (5åˆ†é’Ÿå‰) â†“            â”‚
â”‚  â€¢ document.docx (10åˆ†é’Ÿå‰) â†‘       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å†²çªè§£å†³ç•Œé¢
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âš ï¸  æ£€æµ‹åˆ°å†²çª: project.txt              â”‚
â”‚                                           â”‚
â”‚  æœ¬åœ°ç‰ˆæœ¬:                                 â”‚
â”‚  â€¢ ä¿®æ”¹æ—¶é—´: 2026-01-23 14:30            â”‚
â”‚  â€¢ å¤§å°: 1.2 MB                          â”‚
â”‚  [ æŸ¥çœ‹ ]  [ ä¿ç•™æ­¤ç‰ˆæœ¬ ]                 â”‚
â”‚                                           â”‚
â”‚  è¿œç¨‹ç‰ˆæœ¬ (Windows PC):                   â”‚
â”‚  â€¢ ä¿®æ”¹æ—¶é—´: 2026-01-23 14:35            â”‚
â”‚  â€¢ å¤§å°: 1.3 MB                          â”‚
â”‚  [ æŸ¥çœ‹ ]  [ ä¿ç•™æ­¤ç‰ˆæœ¬ ]                 â”‚
â”‚                                           â”‚
â”‚  [ ä¿ç•™ä¸¤ä¸ªç‰ˆæœ¬ ]  [ å–æ¶ˆ ]               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## æ€»ç»“

åŸºäºç°æœ‰çš„ Airdrop æ¶æ„æ‰©å±•ä¸ºäº‘ç›˜åŒæ­¥ç³»ç»Ÿæ˜¯å®Œå…¨å¯è¡Œçš„ï¼š

**ä¼˜åŠ¿**:
- å·²æœ‰è®¾å¤‡å‘ç°å’Œä¼šè¯ç®¡ç†
- QUIC ä¼ è¾“å±‚é«˜æ•ˆå¯é 
- äº‹ä»¶é©±åŠ¨æ¶æ„æ˜“äºæ‰©å±•

**å·¥ä½œé‡ä¼°ç®—**: 4-8å‘¨å®Œæ•´å®ç°

**æ¨èè·¯çº¿**:
1. å…ˆå®ç°åŸºç¡€å•å‘åŒæ­¥ï¼ˆ2å‘¨ï¼‰
2. å†æ·»åŠ åŒå‘ + å†²çªå¤„ç†ï¼ˆ2å‘¨ï¼‰
3. æœ€åä¼˜åŒ–æ€§èƒ½ï¼ˆå¢é‡ã€å‹ç¼©ç­‰ï¼‰ï¼ˆ2-4å‘¨ï¼‰

éœ€è¦æˆ‘è¯¦ç»†è®¾è®¡æŸä¸ªå…·ä½“æ¨¡å—çš„ä»£ç å—ï¼Ÿ
